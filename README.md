golang-aes-crypto
===============

A simple go struct for encrypting &amp; decrypting strings。

# Features

Here are the features of this struct. We believe that these properties are consistent with what a lot of people are looking for when encrypting Strings in golang.

* *Works for strings*: It should encrypt arbitrary strings or byte arrays. This means it needs to effectively handle multiple blocks (CBC) and partial blocks (padding). It consistently serializes and deserializes ciphertext, IVs, and key material using base64 to make it easy to store.
* *Algorithm & Mode*: We chose: AES 128, CBC, and PKCS5 padding. We would have picked GCM for its built-in integrity checking, but that's only available since Android Jelly Bean.
* *IV Handling*: We securely generate a random IV before each encryption and provide a simple class to keep the IV and ciphertext together so they're easy to keep track of and store. We set the IV and then request it back from the Cipher class for compatibility across various Android versions.
* *Integrity*: Lots of people think AES has integrity checking built in. The thinking goes, "if it decrypts correctly, it was generated by the person with the private key". Actually, AES CBC allows an attacker to modify the messages. Therefore, we've also added integrity checking in the form of a SHA 256 hash.


# How to include in project?

## Copy and paste

It's a very simple go struct,The struct should be easy to paste into an existing codebase.

## Go Dependency

```go
    go get github.com/ChengjinWu/aescrypto
```


# Examples


## aes、ecb、pkcs7加密解密算法

```go
  /*
  	*src 要加密的字符串
  	*key 用来加密的密钥 密钥长度可以是128bit、192bit、256bit中的任意一个
  	*16位key对应128bit
  	 */
  	src := "10001111111111111111111111111123456789"
  	key := "1234123412341234123412341234abcd"

  	crypted, err := aescrypto.AesEcbPkcs5Encrypt([]byte(src), []byte(key))
  	if err != nil {
  		fmt.Println(err)
  	}
  	fmt.Println("base64UrlSafe result:", base64.URLEncoding.EncodeToString(crypted))
  	data, err := aescrypto.AesEcbPkcs5Decrypt(crypted, []byte(key))

  	if err != nil {
  		fmt.Println(err)
  	}
  	fmt.Println("source is :", string(data))
```

## aes、cbc、pkcs7加密解密算法

```go
  	/*
  	*src 要加密的字符串
  	*key 用来加密的密钥 密钥长度可以是128bit、192bit、256bit中的任意一个
  	*16位key对应128bit
  	 */
  	src := "10001111111111111111111111111123456789"
  	key := "1234123412341234123412341234abcd"

  	crypted, err := aescrypto.AesCbcPkcs7Encrypt([]byte(src), []byte(key), nil)
  	if err != nil {
  		fmt.Println(err)
  	}
  	fmt.Println("base64UrlSafe result:", base64.URLEncoding.EncodeToString(crypted))
  	data, err := aescrypto.AesCbcPkcs7Decrypt(crypted, []byte(key), nil)

  	if err != nil {
  		fmt.Println(err)
  	}
  	fmt.Println("source is :", string(data))
```


# License

The included MIT license is compatible with open source or commercial products.
I also offers custom support and licensing terms if your organization has
different needs. Contact us at [369973338@qq.com](369973338@qq.com) for more
details.


